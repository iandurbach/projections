#####################################################################################
#####################################################################################
#####################################################################################
##### INTERPOLATION FUNCTIONS
##### -----------------------
##### File contains functions for different ways of interpolating
##### between points generated by "simulate_at_elicited_times.r"
##### All files take as input a (N x E_t) matrix of values, containing 
##### N simulated values at each of the E_t assessed time points.
##### Other options depend on the kind of interpolation used.
##### Four interpolation methods are given:
##### 1) Linear interpolation when the assessed points are point-in-time values
##### 2) Linear interpolation when the assessed points are means over time
##### 3) A "Gaussian" algorithm when the assessed points are means over time
##### 4) A "random walk" algorithm when the assessed points are point-in-time values
##### NOTE: the random walk algorithm can give strange plots, and is also sensitive 
##### to the parameter "alpha" (which controls the size of the year-to-year changes).
##### Use with caution!
##### Ian Durbach, 4/11/2015
##### ian.durbach@uct.ac.za
#####################################################################################
#####################################################################################
#####################################################################################


#####################################################################################
##### Main function, calls others
#####################################################################################

interpolate_betw_elic_times = function(y,nperiods,method,maxchange=NULL,alpha=NULL)
{
  if(method=="gaussian.from.means"){
    annualdata = apply(y,1,interpolate_gaussian_frommeans,nperiods,maxchange)
  }else if(method=="linear.from.means"){
    annualdata = apply(y,1,interpolate_linear_frommeans,nperiods)    
  }else if(method=="linear.from.points"){
    annualdata = apply(y,1,interpolate_linear_frompoints,nperiods)    
  }else if(method=="rwalk.from.points"){
    random_step_all = compute_random_step(y,nperiods,alpha)
    annualdata = apply(y,1,interpolate_rwalk_frompoints,nperiods,random_step_all) 
  }else{stop("Unrecognized interpolation method specified") }
  return(annualdata)
}

#####################################################################################
##### INTERPOLATION FUNCTION 1
##### Generates simulated data by linear interpolation between
##### key time-points
#####################################################################################

interpolate_linear_frompoints = function(z,nperiods)
{
  
  ntimes = length(nperiods)
  
  z_int = c()
  for(i in 1:ntimes)
  {
    this_seq = seq(from=z[i],to=z[i+1],length=nperiods[i]+2)
    if(i>1){this_seq = this_seq[-1]}
    z_int = c(z_int,this_seq)
  }
  
  return(z_int)
}

#####################################################################################
##### INTERPOLATION FUNCTION 2
##### Generates simulated data by linear interpolation when elicited data is
##### MEANS over periods 2014-2020, 2021-2035, 2036-2050
#####################################################################################

interpolate_linear_frommeans = function(z,nperiods)
{
  
  ntimes = length(nperiods)
  
  z_int = c()
  first_z = c()
  last_z = c()
  for(i in 1:ntimes)
  {
    n = nperiods[i]
    required_sum = z[i+1] * n
    first_z[i] = ifelse(i==1,z[1],last_z[i-1])
    last_z[i] = 2 * required_sum / n - first_z[i]
    
    this_seq = seq(from=first_z[i],to=last_z[i],length=n)
    z_int = c(z_int,this_seq)
  }

  return(z_int)
}

#####################################################################################
##### INTERPOLATION FUNCTION 3
##### Generates simulated yearly data when elicited data is
##### MEANS over periods. Within each period, data are normally distributed with
##### the required mean. The variance is computed as maxchange (a parameter) divided
##### by 6 (6 sigma approx = range). Observations are reordered within time period 
##### to make year-on-year movements slightly less random.
#####################################################################################

interpolate_gaussian_frommeans = function(z,nperiods,maxchange)
{
  
  ntimes = length(nperiods)
  
  z_int = c()
  z_int[1] = z[1]
  z_count = 1
  for(i in 1:ntimes)
  {
    n = nperiods[i]
    
    if(i>1){ 
      zt = rnorm(n,0,maxchange/6)
      zt = zt - mean(zt) + z[i+1]
    }else{
      zt = rnorm(n-1,0,maxchange/6)
      zt = zt - mean(zt) + (n*z[i+1] - z[1])/(n-1)
    }
    
    alreadyused = NULL    
    n = ifelse(i==1,n-1,n)
    for(j in 1:n){
      sampleprobs = (1/abs(10^(-6) + zt - z_int[z_count]))^(1/2)  
      sampleprobs[alreadyused] = 0
      sampleprobs[sampleprobs<0] = 0
      nextobs = sample(1:n,1,prob=sampleprobs)
      z_int[z_count+1] = zt[nextobs]
      alreadyused = c(alreadyused,nextobs)
      z_count = z_count + 1
    } 
  }
  return(z_int)
}

#####################################################################################
##### INTERPOLATION FUNCTION 4
##### Generates simulated yearly data by a "random walk" between
##### key time-points. The basic idea is to fix the end points in each time period,
##### and generate the points in-between as a random walk, subject to some drift 
##### and constraints an period-to-period change. Can give strange results depicting
##### a "pinching" at end-points -- use with caution!
#####################################################################################

interpolate_rwalk_frompoints = function(z,nperiods,random_step_all)
{
  
  endpts = z
  ntimes = length(nperiods)
  totalwalk = c()
  totalwalk[1] = endpts[1]
  
  for(j in 1:ntimes)
  {
    
    n_to_fill = nperiods[j]
    
    drift_step = (endpts[j+1] - endpts[j]) / (n_to_fill + 1)
    random_step = random_step_all[j]
    
    walk = c()
    
    walk[1] = endpts[j]
    
    for(i in 1:n_to_fill)
    {
      poss_next_pos = walk[i] + drift_step + c(-random_step,0,random_step)  
      dist_to_end = endpts[j+1] - poss_next_pos - ((n_to_fill-i+1) * drift_step)
      max_dist_poss = (n_to_fill-i+1) * random_step
      selection_probs <- ifelse(abs(dist_to_end)<=max_dist_poss,1.0001 - abs(dist_to_end)/max_dist_poss,0)
      this_move <- sample(c(-random_step,0,random_step),1,prob=selection_probs)
      walk[1+i] = walk[i] + drift_step + this_move
    }
    
    walk[n_to_fill+2] = endpts[j+1]
    
    totalwalk = c(totalwalk,walk[-1])
    
  }
  
  return(totalwalk)
  
}

compute_random_step = function(y,nperiods,alpha){
  random_step_all = c()
  for(j in 1:length(nperiods))
  {
    random_step_all[j] = alpha * mean(abs((y[,j+1] - y[,j])/nperiods[j]))    
  }
  return(random_step_all)
}



